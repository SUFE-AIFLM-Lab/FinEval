[
    {
        "id": "c1589fe1-0ef6-42ed-9a53-df10247b98e7",
        "question": "为了防止软件系统中潜在的后门威胁，以下哪一步骤是确保软件安全性的有效方法？",
        "A": "A: 审查代码，特别是那些处理用户认证和数据传输的部分。",
        "B": "B: 验证软件的数字签名，并与可信赖的来源的哈希值进行对比。",
        "C": "C: 在隔离的沙箱环境中部署软件，并对其行为进行观察。",
        "D": "D: 限制软件的操作权限，仅允许读取数据以防止未授权的修改。",
        "answer": "B"
    },
    {
        "id": "578d4696-6d4e-4cdb-8859-2199dd1a919d",
        "question": "在Java Server Page (JSP)应用程序中，开发者在JSP代码中加入了一条注释，内容为'<!-- FIXME: 调用超过30个参数会导致JDBC服务器崩溃 -->'。这种做法可能带来的安全隐患是什么？",
        "A": "A: 它为将来的维护提供了文档记录，没有安全隐患。",
        "B": "B: 如果攻击者发现了这条注释并滥用这个漏洞，可能会导致拒绝服务(DoS)攻击。",
        "C": "C: 该注释会被服务器预处理，因此不会有信息泄露的风险。",
        "D": "D: 这类注释会增加应用程序的响应时间，可能会拖慢服务器。",
        "answer": "B"
    },
    {
        "id": "beb2131f-317a-4531-a732-1161682a4830",
        "question": "为了提高组织中Apple设备的安全性，IT安全经理应该考虑实施哪些措施来防御暴力破解攻击？",
        "A": "在iOS和iPadOS设备上，连续输入10次错误密码后启用数据擦除功能。",
        "B": "在macOS设备的登录窗口设置最多允许5次密码尝试。",
        "C": "在iOS设备上禁用数据保护功能，避免加密密钥泄露。",
        "D": "在iOS、iPadOS和macOS设备上，实施错误密码输入后的时间递增延迟。",
        "answer": "D"
    },
    {
        "id": "f0ee080a-4ef9-414a-a51c-920c721c9349",
        "question": "检查以下代码段，指出哪个没有因不正确处理资源关闭而导致潜在的安全问题：",
        "A": "A: int fd = open(\"data.bin\", O_RDONLY); if (fd != -1) { /* 读取数据 */ close(fd); }",
        "B": "B: char *msg = (char *)malloc(128 * sizeof(char)); if (msg) { /* 处理消息 */ free(msg); free(msg); }",
        "C": "C: FILE *file_ptr = fopen(\"log.txt\", \"w\"); if (file_ptr) { /* 写入日志 */ fclose(file_ptr); fclose(file_ptr); }",
        "D": "D: int *array = new int[50]; if (array) { /* 使用数组 */ delete [] array; }",
        "answer": "A"
    },
    {
        "id": "63e66505-5d22-47fd-b5fd-5c7d3095e4de",
        "question": "在进行代码审查时，发现大量使用全局变量的主要缺点是什么？",
        "A": "A: 它可能使得代码库更加难以维护，因为组件之间的耦合度增加了。",
        "B": "B: 全局变量可以提高应用程序的性能，因为它减少了参数传递的需要。",
        "C": "C: 过度使用全局变量可能会导致调试时出现不可预料的问题。",
        "D": "D: 全局变量可以简化应用程序状态的管理，尤其是在大型复杂的系统中。",
        "answer": "C"
    },
    {
        "id": "f68f67f4-2e6e-45ca-aa5d-b7d52661ffa8",
        "question": "开发团队负责保护Web服务免受注入漏洞的攻击。他们正在评估处理用户输入的不同策略。根据对抗注入漏洞的潜在有效性，分析以下策略的优缺点：",
        "A": "A: 使用黑名单来阻止已知的恶意输入。",
        "B": "B: 在验证之前将输入规范化为一致的内部表示。",
        "C": "C: 仅依赖白名单来确定输入的有效性。",
        "D": "D: 不考虑输入验证策略，对所有输出进行编码。",
        "answer": "B"
    },
    {
        "id": "691cf855-4150-42e2-9967-b78cce393208",
        "question": "在软件开发中，使用全局变量维护不同组件之间的状态可能会导致哪种问题？",
        "A": "A: 它可能导致组件之间的耦合更紧密，使得代码库更难维护和理解。",
        "B": "B: 全局变量可能通过减少参数传递的开销来提高应用程序的性能。",
        "C": "C: 过度依赖全局变量可能会导致意外的副作用，使得调试更加困难。",
        "D": "D: 全局变量简化了大型复杂系统中应用状态的管理。",
        "answer": "A"
    },
    {
        "id": "3d9d2cbf-1670-4206-ba88-cd13028c3bea",
        "question": "在设计会议中，开发人员提出了一个新功能，其中包括一个用于汇总多个来源数据的对象。该对象预计至少有十个子元素，每个子元素本身都是一个复杂对象。对于提出的设计，应该提出哪些担忧？",
        "A": "提出的设计可能会导致数据处理流程更高效、更流畅。",
        "B": "复杂子元素的高数量可能会导致内存消耗增加和数据处理速度变慢。",
        "C": "设计可能会由于每个子元素的独立处理而降低安全漏洞的风险。",
        "D": "如果管理聚合对象的代码可供攻击者访问，可能会容易受到与性能相关的安全漏洞的攻击。",
        "answer": "B"
    },
    {
        "id": "6288d458-fcff-410b-9274-a4d27e0ab647",
        "question": "在开发新软件项目时，为了降低内存管理漏洞的风险，开发团队在选择编程语言时应该优先考虑哪项特性？",
        "A": "选择允许程序员完全控制内存分配和回收的手动内存管理语言。",
        "B": "选择提供自动内存管理功能的语言，以避免手动分配和回收内存时的错误。",
        "C": "选择支持多继承的语言，以提高面向对象设计和代码复用性。",
        "D": "选择拥有广泛标准库的语言，以减少编写自定义代码的需求。",
        "answer": "B"
    },
    {
        "id": "5d772945-dec6-4fc0-9a5f-acb015426e81",
        "question": "在网络安全中，以下哪项措施不能有效防止ARP欺骗攻击？",
        "A": "使用动态ARP检查机制。",
        "B": "部署静态ARP记录。",
        "C": "实施网络访问控制策略。",
        "D": "允许交换机在ARP表溢出时转为集线器模式。",
        "answer": "D"
    },
    {
        "id": "83574f69-c312-40f6-a763-a656c6c30ebc",
        "question": "在网络安全中，哪种加密算法是对称加密的例子？",
        "A": "AES",
        "B": "RSA",
        "C": "SHA-256",
        "D": "ECC",
        "answer": "A"
    },
    {
        "id": "19f097f8-008c-4e32-9a68-9705b79ca202",
        "question": "在软件系统中，密码等关键数据元素为什么要声明为私有？",
        "A": "私有数据元素更容易被程序的其他部分访问和修改，这有助于简化开发过程。",
        "B": "声明数据元素为私有可以防止数据被未授权访问和意外更改。",
        "C": "公开数据元素可以提高代码的灵活性，因为它们可以更容易地与第三方服务集成。",
        "D": "公开数据元素是为了在多线程环境中获得更好的性能。",
        "answer": "B"
    },
    {
        "id": "2433d28e-6367-424f-b0dc-4191c5260676",
        "question": "在构建一个新的网络应用程序时，你需要选择一种协议来保护数据传输的安全。以下哪种协议最适合确保数据在传输过程中的安全性？",
        "A": "HTTP",
        "B": "HTTPS",
        "C": "FTP",
        "D": "SMTP",
        "answer": "B"
    },
    {
        "id": "dc98a59b-acb0-465e-9d73-42e322f7d6dd",
        "question": "以下哪项不是一种常见的网络钓鱼攻击手段？",
        "A": "发送带有恶意附件的电子邮件",
        "B": "通过合法网站的弹出窗口进行欺诈",
        "C": "在社交媒体上发布虚假广告",
        "D": "使用防火墙阻止未授权访问",
        "answer": "D"
    },
    {
        "id": "e5a6e701-be1b-4920-851a-243770bdf0a7",
        "question": "在最近的应用程序安全审计中，发现用于加密操作的伪随机数生成器(PRNG)偶尔以一种弱的方式失败，导致可预测的结果。这个问题的原因可能是什么？",
        "A": "PRNG可能没有使用高质量的熵源重新种子化；考虑实现一个使用硬件设备重新种子化的PRNG。",
        "B": "PRNG可能不符合公认的标准；确保它符合FIPS 140-2标准，特别是附录C的指南。",
        "C": "PRNG可能使用了一个弱算法；用一个提供一致保护水平的更安全算法替换它。",
        "D": "应用程序可能不需要高熵；验证低熵PRNG是否满足其安全需求。",
        "answer": "A"
    },
    {
        "id": "f7dedc8d-4512-470a-87e7-b9874ffa7ccc",
        "question": "在对一个应用程序进行安全审计时，发现其使用的密码学操作的伪随机数生成器(PRNG)有时会产生可预测的结果，这表明存在安全隐患。为了解决这个问题，应该采取哪些措施？",
        "A": "检查PRNG是否定期使用高质量的熵源进行重新种子化，并在必要时进行改进。",
        "B": "确保PRNG遵循FIPS 140-2标准，尤其是附录C中的规范。",
        "C": "更换使用弱加密算法的PRNG，采用一个经过验证的、安全性更高的算法。",
        "D": "评估应用程序对熵的需求，如果低熵PRNG足够，则无需更改。",
        "answer": "C"
    },
    {
        "id": "dd327cb6-219e-4afa-a49c-7f3b0a7cd18e",
        "question": "考虑以下代码片段，它旨在创建一个以空字符结尾的字符串并打印其内容：char *foo; int counter; foo = calloc(sizeof(char) * 10); for (counter = 0; counter != 10; counter++) { foo[counter] = 'a'; printf(\"%s\\n\", foo); } 如果循环条件错误地更改为'counter < 10'，可能会出现什么潜在后果？",
        "A": "printf()函数将正确无误地打印字符串'foo'。",
        "B": "字符串'foo'将不会以空字符结尾，当打印时可能导致缓冲区溢出。",
        "C": "循环将提前终止，导致字符串中少于9个'a'字符。",
        "D": "将发生无限循环，因为循环条件永远不会评估为假。",
        "answer": "B"
    },
    {
        "id": "5589ccd9-65ae-498d-8a2e-d94fd470dcd0",
        "question": "在开发应用程序时，如果需要在客户端存储私密数据，以下哪种做法最不安全？",
        "A": "A: 使用强加密算法对数据进行加密存储。",
        "B": "B: 将数据存储在本地数据库中，不进行加密。",
        "C": "C: 通过安全的API将数据传输到服务器端进行加密存储。",
        "D": "D: 使用自定义的简单编码方法对数据进行编码后存储。",
        "answer": "B"
    },
    {
        "id": "c5dc9544-7dee-4955-96f9-c24288cd77ad",
        "question": "在设计ASP.NET应用程序时，为了提高安全性，应该采取哪种错误处理策略？",
        "A": "A: 为所有用户启用框架默认的错误页面。",
        "B": "B: 在代码中捕获异常，并将所有类型的错误引导至自定义错误页面。",
        "C": "C: 修改代码以处理错误，确保返回的总是通用的成功信息。",
        "D": "D: 设计一个详尽的错误页面，用于在服务器端记录错误，同时向用户展示一个简洁的错误信息。",
        "answer": "B"
    },
    {
        "id": "74fb1518-acf3-4737-b9c6-1867f0e9d3fa",
        "question": "在设计一个安全敏感的系统时，工程团队应该采取哪种策略来减轻宇宙辐射引起的单粒子翻转（SEUs）对系统操作的风险？",
        "A": "A: 为SRAM的每个字增加奇偶校验位以实现错误检测和纠正。",
        "B": "B: 在安全敏感模块周围实施三模冗余。",
        "C": "C: 将存储安全关键数据的SRAM替换为非易失性内存类型以防止位翻转。",
        "D": "D: 为存储安全关键数据的SRAM使用纠错码（ECC）和地址交织。",
        "answer": "D"
    },
    {
        "id": "63f5ddd2-0024-485c-8297-21d92f312216",
        "question": "在ASP.NET应用程序的架构和设计阶段，你正在评估不同的错误处理设计策略。以下哪种方法能在不处理或掩盖错误的情况下有效提高安全性？",
        "A": "A: 配置应用程序对所有用户使用框架的默认错误页面。",
        "B": "B: 在源代码中处理异常，并将所有错误，无论来源如何，都定向到自定义错误页面。",
        "C": "C: 尝试在代码中处理错误，返回一个通用的成功消息而不是错误消息。",
        "D": "D: 创建一个详细的错误页面，在服务器上记录错误，但向用户显示一个通用的错误消息。",
        "answer": "B"
    },
    {
        "id": "63a0a3f7-d564-488d-892f-5b407fc390f3",
        "question": "在设计一个使用cookie进行关键操作的应用程序时，以下哪项措施不推荐使用，因为它可能引入安全漏洞？",
        "A": "A: 使用HTTPS来防止cookie在传输过程中被截获。",
        "B": "B: 依赖客户端脚本在做出安全决策前验证cookie数据。",
        "C": "C: 实施内容安全策略（CSP）以降低跨站脚本攻击的风险。",
        "D": "D: 为cookie添加安全标记，确保它们只通过加密连接发送。",
        "answer": "B"
    },
    {
        "id": "4ae2b706-153d-4802-965e-e9a598890414",
        "question": "应用程序开发人员需要在应用程序的可执行文件中存储敏感信息，例如API密钥。考虑到攻击者可以反向工程二进制代码以获取机密数据，以下哪种方法存储这些信息最为安全？",
        "A": "A: 在将敏感信息嵌入到可执行文件之前，使用对称密钥算法对其进行加密。",
        "B": "B: 使用标准压缩算法压缩敏感信息以减小其大小，然后将其存储在可执行文件中。",
        "C": "C: 使用base64编码对敏感信息进行编码并存储在可执行文件中。",
        "D": "D: 将敏感信息存储在可执行文件外部的单独配置文件中，并对该文件进行加密。",
        "answer": "D"
    },
    {
        "id": "83babe0d-bfe0-48cb-be26-81a34b615ff4",
        "question": "在以下哪种情况下，用户输入最有可能导致SQL注入攻击？",
        "A": "A: 用户输入被作为查询的一部分直接传递到数据库。",
        "B": "B: 用户输入在传递到数据库之前，经过了严格的输入验证。",
        "C": "C: 用户输入用于数据库查询时，采用了参数化查询。",
        "D": "D: 用户输入在服务器端被哈希处理后用于查询。",
        "answer": "A"
    },
    {
        "id": "63bf5ca2-5535-4b75-bd55-d64973c110f5",
        "question": "以下哪个是网络钓鱼攻击的常见迹象？",
        "A": "网站使用HTTPS协议",
        "B": "URL中包含多个子域名",
        "C": "收到来自未知发件人的电子邮件",
        "D": "电子邮件中包含拼写错误和语法错误",
        "answer": "D"
    },
    {
        "id": "fa15c6c4-0b38-433b-be0c-b34ff1819d32",
        "question": "当Web应用程序在接收到非法输入时显示出详细的堆栈跟踪信息，包括底层框架和版本号，这可能导致哪种安全问题？",
        "A": "A: 它有助于提供详细的错误信息，从而提升用户解决问题的能力。",
        "B": "B: 它使得攻击者能够识别使用的API和框架，从而更容易地实施有针对性的攻击。",
        "C": "C: 它让开发者在生产环境中更容易地获取调试信息。",
        "D": "D: 它通过避免记录无关紧要的错误信息来提升系统的性能。",
        "answer": "B"
    },
    {
        "id": "fa26dd5d-7db2-4257-a63b-370c51f3c1b5",
        "question": "在软件系统中，为什么应该将密码等关键数据元素声明为私有而不是公开？",
        "A": "私有数据元素可以更容易地被程序的其他部分访问和修改，从而简化开发。",
        "B": "将数据元素声明为私有有助于保护数据免受未经授权的访问和意外修改。",
        "C": "公开数据元素通过允许更容易地与第三方服务集成来增强代码的灵活性。",
        "D": "使数据元素公开是实现多线程环境中高性能的要求。",
        "answer": "B"
    }
]